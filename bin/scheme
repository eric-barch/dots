#!/bin/sh
# Set terminal colors

# Paths
SCHEMES_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/theme/schemes/base16"
STATE_FILE="${XDG_STATE_HOME:-$HOME/.local/state}/scheme"

# Helpers
set_state() {
  key=$1; val=$2
  tmp="${STATE_FILE}.tmp.$$"

  [ -r "$STATE_FILE" ] && cp "$STATE_FILE" "$tmp" || : > "$tmp"

  if grep -q "^$key=" "$tmp"; then
    sed "s/^$key=.*/$key=$val/" "$tmp" > "$tmp.new" && mv "$tmp.new" "$tmp"
  else
    printf '%s=%s\n' "$key" "$val" >> "$tmp"
  fi

  mv "$tmp" "$STATE_FILE"
}

get_state() {
  [ -r "$STATE_FILE" ] && grep "^$1=" "$STATE_FILE" | sed 's/^[^=]*=//'
}

get_filepath_stem() {
  basename=${1##*/}
  printf '%s\n' "${basename%.*}"
}

get_scheme_filepath() {
  filepath="$SCHEMES_DIR/$1.y*ml"
  set -- $filepath
  [ -r "$1" ] && printf '%s\n' "$1" || return 1
}

get_random_scheme_filepath() {
  set -- "$SCHEMES_DIR/"*.y*ml

  [ -r "$1" ] || {
    echo "no scheme files found in $SCHEMES_DIR" >&2
    return 1
  }

  count=$#

  # Read two bytes from `/dev/urandom` and print as a 16-bit integer (0–65535)
  # `od`: octal dump (from `coreutils`)
  # `-An`: no address — suppress offset column
  # `-N2`: read 2 bytes
  # `-tu2`: output as unsigned 2-byte integer
  # `tr`: translate/delete characters
  # `-d`: delete
  random_num=$(od -An -N2 -tu2 /dev/urandom 2>/dev/null | tr -d ' ')

  # If `$random_num` is empty, generate pseudo-random number by concatenating process
  # ID (`$$`) and current timestamp (or 1 if `date` fails).
  [ -n "$random_num" ] || random_num=$$$(date +%s 2>/dev/null || echo 1)

  target_index=$(( random_num % count ))

  index=0
  for filepath in "$@"; do
    [ $index -eq $target_index ] && {
      printf '%s\n' "$filepath"
      return
    }
    index=$(( index + 1 ))
  done
}

parse_scheme_file() {
  filepath="$1"
  for i in $(seq 0 15); do
    key=$(printf 'base%02X' "$i")
    hex=$(sed -nE 's/^[[:space:]]*'"$key"':[[:space:]]*"[#]?([0-9A-Fa-f]{6}).*$/\1/p' "$filepath" | head -n1)
    [ -n "$hex" ] || {
      echo "parse error: missing $key" >&2
      return 1
    }
    printf '%s\n' "$hex"
  done
}

emit_osc()  {
  code="$1"; hex="$2"
  printf '\033]%s;#%s\033\\' "$code" "$hex"
}

emit_osc_4() {
  index="$1"; hex="$2"
  printf '\033]4;%s;#%s\033\\' "$index" "$hex"
}

apply_scheme() {
  set --
  while IFS= read -r line; do
    set -- "$@" "$line"
  done

  [ $# -ge 16 ] || {
    echo "scheme parse yielded fewer than 16 colors" >&2
    return 1
  }

  emit_osc 10 "$6"
  emit_osc 11 "$1"
  emit_osc 12 "${14}"

  emit_osc_4 0  "$1"
  emit_osc_4 1  "$9"
  emit_osc_4 2  "${12}"
  emit_osc_4 3  "${11}"
  emit_osc_4 4  "${14}"
  emit_osc_4 5  "${15}"
  emit_osc_4 6  "${13}"
  emit_osc_4 7  "$6"

  emit_osc_4 8  "$4"
  emit_osc_4 9  "$9"
  emit_osc_4 10 "${12}"
  emit_osc_4 11 "${11}"
  emit_osc_4 12 "${14}"
  emit_osc_4 13 "${15}"
  emit_osc_4 14 "${13}"
  emit_osc_4 15 "$8"

  emit_osc_4 16 "${10}"
  emit_osc_4 17 "${16}"
  emit_osc_4 18 "$2"
  emit_osc_4 19 "$3"
  emit_osc_4 20 "$5"
  emit_osc_4 21 "$7"
}

show_usage() {
  cat <<EOF
usage: scheme [-l|--last] [-r|--random] [-d|--default] [<scheme>]

Flags:
  -l, --last      use last scheme
  -r, --random    use random scheme
  -d, --default   if <scheme> provided, set default=<scheme>; else default=last
EOF
  exit 0
}

determine_scheme_filepath() {
  arg_scheme=$1
  use_last=$2
  use_random=$3

  if [ -n "$arg_scheme" ]; then
    get_scheme_filepath "$arg_scheme" && return 0
    echo "error: scheme not found: $arg_scheme" >&2
    return 1
  fi

  if [ "$use_last" -eq 1 ]; then
    last_scheme=$(get_state last)
    [ -n "$last_scheme" ] || { echo "error: no 'last' scheme in $STATE_FILE" >&2; return 1; }
    get_scheme_filepath "$last_scheme" && return 0
    echo "error: scheme not found: $last_scheme" >&2
    return 1
  fi

  if [ "$use_random" -eq 1 ]; then
    get_random_scheme_filepath && return 0
    echo "error: no scheme files found in $SCHEMES_DIR" >&2
    return 1
  fi

  default_scheme=$(get_state default)
  [ -n "$default_scheme" ] || { echo "error: no 'default' scheme in $STATE_FILE" >&2; return 1; }
  get_scheme_filepath "$default_scheme" && return 0
  echo "error: scheme not found: $default_scheme" >&2
  return 1
}

# Parse args
show_help=0
use_last=0
use_random=0
set_default=0
arg_scheme=""

while [ $# -gt 0 ]; do
  case "${1:-}" in
    -h|--help) show_help=1 ;;
    -l|--last) use_last=1 ;;
    -r|--random) use_random=1 ;;
    -d|--default) set_default=1 ;;
    --) shift; break ;;
    -*) echo "Unknown flag: $1" >&2; show_usage ;;
    *) arg_scheme="$1" ;;
  esac
  shift || true
done

# Core logic
if [ "$show_help" -eq 1 ]; then
  show_usage
  exit 0
fi

filepath=$(determine_scheme_filepath "$use_last" "$use_random" "$set_default" "$arg_scheme") || {
  echo "error: failed to get filepath" >&2
  exit 1
}

parse_scheme_file "$filepath" | apply_scheme || {
  echo "error: failed to apply scheme" >&2
  exit 1
}

scheme=$(get_filepath_stem "$filepath")

echo "applied scheme: $scheme"

set_state last "$scheme"

if [ "$set_default" -eq 1 ]; then
  set_state default "$scheme"
fi

exit 0
