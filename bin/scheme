#!/bin/sh
# Set terminal colors

# Paths
SCHEMES_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/theme/schemes/base16"
STATE_FILE="${XDG_STATE_HOME:-$HOME/.local/state}/scheme"

# Helpers
set_state() {
  key=$1; val=$2
  tmp="${STATE_FILE}.tmp.$$"

  [ -r "$STATE_FILE" ] && cp "$STATE_FILE" "$tmp" || : > "$tmp"

  if grep -q "^$key=" "$tmp"; then
    sed "s/^$key=.*/$key=$val/" "$tmp" > "$tmp.new" && mv "$tmp.new" "$tmp"
  else
    printf '%s=%s\n' "$key" "$val" >> "$tmp"
  fi

  mv "$tmp" "$STATE_FILE"
}

get_state() {
  [ -r "$STATE_FILE" ] && grep "^$1=" "$STATE_FILE" | sed 's/^[^=]*=//'
}

get_filepath_stem() {
  base_name="${1##*/}"
  stem="${file%.*}"
  printf '%s\n' "$stem"
}

get_scheme_filepath() {
  filepath="$SCHEMES_DIR/$1.y*ml"
  set -- $filepath
  [ -r "$1" ] && printf '%s\n' "$1" || return 1
}

get_random_scheme_filepath() {
  set -- "$SCHEMES_DIR/"*.y*ml

  [ -r "$1" ] || {
    echo "no scheme files found in $SCHEMES_DIR" >&2
    return 1
  }

  count=$#

  # Read two bytes from `/dev/urandom` and print as a 16-bit integer (0–65535)
  # `od`: octal dump (from `coreutils`)
  # `-An`: no address — suppress offset column
  # `-N2`: read 2 bytes
  # `-tu2`: output as unsigned 2-byte integer
  # `tr`: translate/delete characters
  # `-d`: delete
  random_num=$(od -An -N2 -tu2 /dev/urandom 2>/dev/null | tr -d ' ')

  # If `$random_num` is empty, generate pseudo-random number by concatenating process
  # ID (`$$`) and current timestamp (or 1 if `date` fails).
  [ -n "$random_num" ] || random_num=$$$(date +%s 2>/dev/null || echo 1)

  target_index=$(( random_num % count ))

  index=0
  for filepath in "$@"; do
    [ $index -eq $target_index ] && {
      printf '%s\n' "$filepath"
      return
    }
    index=$(( index + 1 ))
  done
}

parse() {
  file="$1"
  for key in base00 base01 base02 base03 base04 base05 base06 base07 base08 base09 base0A base0B base0C base0D base0E base0F; do
    hex=$(sed -nE 's/^[[:space:]]*'"$key"':[[:space:]]*"[#]?([0-9A-Fa-f]{6}).*$/\1/p' "$file" | head -n1)
    [ -n "$hex" ] || { echo "parse error: missing $key" >&2; return 1; }
    printf '%s\n' "$hex"
  done
}

osc_set_color() { idx="$1"; hex="$2"; printf '\033]4;%s;#%s\033\\' "$idx" "$hex"; }
osc_set_10() { printf '\033]10;#%s\033\\' "$1"; }  # foreground
osc_set_11() { printf '\033]11;#%s\033\\' "$1"; }  # background
osc_set_12() { printf '\033]12;#%s\033\\' "$1"; }  # cursor color

apply() {
  set --
  while IFS= read -r line; do set -- "$@" "$line"; done
  [ $# -ge 16 ] || { echo "scheme parse yielded fewer than 16 colors" >&2; return 1; }

  osc_set_color 0  "$1"
  osc_set_color 1  "$9"
  osc_set_color 2  "${12}"
  osc_set_color 3  "${11}"
  osc_set_color 4  "${14}"
  osc_set_color 5  "${15}"
  osc_set_color 6  "${13}"
  osc_set_color 7  "$6"

  osc_set_color 8  "$4"
  osc_set_color 9  "$9"
  osc_set_color 10 "${12}"
  osc_set_color 11 "${11}"
  osc_set_color 12 "${14}"
  osc_set_color 13 "${15}"
  osc_set_color 14 "${13}"
  osc_set_color 15 "$8"

  osc_set_color 16 "${10}"
  osc_set_color 17 "${16}"
  osc_set_color 18 "$2"
  osc_set_color 19 "$3"
  osc_set_color 20 "$5"
  osc_set_color 21 "$7"

  # fg/bg/cursor
  osc_set_10 "$6"
  osc_set_11 "$1"
  osc_set_12 "${14}"
}

usage() {
  cat <<EOF
usage: scheme [-l|--last] [-r|--random] [-d|--default] [<scheme>]

Flags:
  -l, --last      use last scheme
  -r, --random    use random scheme
  -d, --default   if <scheme> provided, set default=<scheme>; else default=last
EOF
  exit 0
}

# Parse flags
use_last=0
use_random=0
set_default=0
show_help=0
arg_scheme=""

while [ $# -gt 0 ]; do
  case "${1:-}" in
    -l|--last) use_last=1 ;;
    -r|--random) use_random=1 ;;
    -d|--default) set_default=1 ;;
    -h|--help) usage ;;
    --) shift; break ;;
    -* ) echo "Unknown flag: $1" >&2; usage ;;
    * ) arg_scheme="$1" ;;
  esac
  shift || true
done

# Resolve scheme path/name
choose_scheme() {
  if [ "$use_random" -eq 1 ]; then
    get_random_scheme_filepath
    return
  fi

  if [ -n "$arg_scheme" ]; then
    if path="$(get_scheme_filepath "$arg_scheme")"; then
      printf '%s\n' "$path"; return
    fi
    echo "scheme not found: $arg_scheme" >&2
    return 1
  fi

  if [ "$use_last" -eq 1 ] || [ -z "$arg_scheme" ]; then
    last="$(get_state last || true)"
    [ -n "${last:-}" ] || { echo "no last scheme in state. provide a scheme or use --random" >&2; return 1; }
    if path="$(get_scheme_filepath "$last")"; then
      printf '%s\n' "$path"; return
    fi
    echo "last scheme not found under \$SCHEMES_DIR: $last" >&2
    return 1
  fi
}

scheme_file="$(choose_scheme)" || exit 1


# Apply palette
parse "$scheme_file" | apply || exit 1

set_state last "$(get_filepath_stem "$scheme_file")"

if [ "$set_default" -eq 1 ]; then
  set_state default "$(get_state last)"
fi

echo "Applied scheme: $(get_filepath_stem "$scheme_file")"
