#!/bin/sh
# Set terminal colors

# Paths
SCHEMES_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/theme/schemes/base16"
STATE_FILE="${XDG_STATE_HOME:-$HOME/.local/state}/scheme"

# Helpers
set_state() {
  key="$1"; val="$2"
  tmp="$STATE_FILE.tmp"
  [ -f "$STATE_FILE" ] && grep -vE "^$key=" "$STATE_FILE" > "$tmp" || :
  printf '%s=%s\n' "$key" "$val" >> "$tmp"
  mv "$tmp" "$STATE_FILE"
}

get_state() {
  if [ -f "$STATE_FILE" ]; then
    grep -E "^$1=" "$STATE_FILE" | sed 's/^[^=]*=//'
  fi
}

pick_random() {
  set -- "$SCHEMES_DIR"/*.y*ml
  [ -e "$1" ] || { echo "no scheme files found in $SCHEMES_DIR" >&2; return 1; }
  count=$#
  num=$(od -An -N2 -tu2 /dev/urandom 2>/dev/null | tr -d ' ')
  [ -n "$num" ] || num=$$$(date +%s 2>/dev/null || echo 1)
  n=$(( (num % count) + 1 ))
  i=1
  for f in "$@"; do
    [ $i -eq $n ] && { printf '%s\n' "$f"; return; }
    i=$((i+1))
  done
}

parse() {
  file="$1"
  for key in base00 base01 base02 base03 base04 base05 base06 base07 base08 base09 base0A base0B base0C base0D base0E base0F; do
    hex=$(sed -nE 's/^[[:space:]]*'"$key"':[[:space:]]*"[#]?([0-9A-Fa-f]{6}).*$/\1/p' "$file" | head -n1)
    [ -n "$hex" ] || { echo "parse error: missing $key" >&2; return 1; }
    printf '%s\n' "$hex"
  done
}

osc_set_color() { idx="$1"; hex="$2"; printf '\033]4;%s;#%s\033\\' "$idx" "$hex"; }
osc_set_10() { printf '\033]10;#%s\033\\' "$1"; }  # foreground
osc_set_11() { printf '\033]11;#%s\033\\' "$1"; }  # background
osc_set_12() { printf '\033]12;#%s\033\\' "$1"; }  # cursor color

apply() {
  set --
  i=0
  while IFS= read -r line; do set -- "$@" "$line"; i=$((i+1)); done
  [ $# -ge 16 ] || { echo "Scheme parse yielded fewer than 16 colors" >&2; return 1; }

  osc_set_color 0  "$1"
  osc_set_color 1  "$9"
  osc_set_color 2  "${12}"
  osc_set_color 3  "${11}"
  osc_set_color 4  "${14}"
  osc_set_color 5  "${15}"
  osc_set_color 6  "${13}"
  osc_set_color 7  "$6"
  osc_set_color 8  "$4"
  osc_set_color 9  "$9"
  osc_set_color 10 "${12}"
  osc_set_color 11 "${11}"
  osc_set_color 12 "${14}"
  osc_set_color 13 "${15}"
  osc_set_color 14 "${13}"
  osc_set_color 15 "$8"

  # fg/bg/cursor
  osc_set_10 "$6"  # base05
  osc_set_11 "$1"  # base00
  osc_set_12 "${14}" # base0D
}

usage() {
  cat <<EOF
usage: scheme [-l|--last] [-r|--random] [-d|--default] [<scheme>]

Flags:
  -l, --last      use last scheme
  -r, --random    use random scheme
  -d, --default   if <scheme> provided, set default=<scheme>; else default=last
EOF
  exit 0
}

# Parse flags
use_last=0
use_random=0
set_default=0
arg_scheme=""

while [ $# -gt 0 ]; do
  case "${1:-}" in
    -l|--last) use_last=1 ;;
    -r|--random) use_random=1 ;;
    -d|--default) set_default=1 ;;
    -h|--help) usage ;;
    --) shift; break ;;
    -* ) echo "Unknown flag: $1" >&2; usage ;;
    * ) arg_scheme="$1" ;;
  esac
  shift || true
done

# Resolve scheme path/name
choose_scheme() {
  if [ "$use_random" -eq 1 ]; then
    pick_random
    return
  fi

  if [ -n "$arg_scheme" ]; then
    if [ -f "$arg_scheme" ]; then
      printf '%s\n' "$arg_scheme"
      return
    fi
    # try name -> file in SCHEMES_DIR (accept .yml or .yaml, with or without extension)
    base="$SCHEMES_DIR/$arg_scheme"
    if [ -f "$base" ]; then printf '%s\n' "$base"; return; fi
    if [ -f "$base.yml" ]; then printf '%s\n' "$base.yml"; return; fi
    if [ -f "$base.yaml" ]; then printf '%s\n' "$base.yaml"; return; fi
    echo "Scheme not found: $arg_scheme" >&2; return 1
  fi

  if [ "$use_last" -eq 1 ] || [ -z "$arg_scheme" ]; then
    last="$(get_state last || true)"
    [ -n "${last:-}" ] || { echo "No last scheme in state. Provide a scheme or use --random" >&2; return 1; }
    printf '%s\n' "$last"
    return
  fi
}

scheme_file="$(choose_scheme)" || exit 1

head -n 40 -- "$scheme_file" >&2

# Apply palette
parse "$scheme_file" | apply || exit 1

# Save last
# Store canonical path to enable --last even if you moved CWD
case "$scheme_file" in
  /*) set_state last "$scheme_file" ;;
  *)  set_state last "$(cd "$(dirname "$scheme_file")" && pwd)/$(basename "$scheme_file")" ;;
esac

# Handle --default
if [ "$set_default" -eq 1 ]; then
  if [ -n "$arg_scheme" ]; then
    # default = the chosen arg-resolved scheme
    set_state default "$(get_state last)"
  else
    # no <scheme> provided -> default = last (per your spec)
    set_state default "$(get_state last)"
  fi
fi

# Echo the active scheme name
bn="$(basename "$scheme_file")"
echo "Applied scheme: ${bn%.*}"
