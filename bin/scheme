#!/bin/sh
# Set terminal colors

# Paths
SCHEMES_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/schemes/base16"
STATE_FILE="${XDG_STATE_HOME:-$HOME/.local/state}/scheme"

# Helpers
set_scheme_state() {
  key="$1"; val="$2"

  tmp="${STATE_FILE}.tmp.$$"

  [ -r "$STATE_FILE" ] && cp "$STATE_FILE" "$tmp" || : > "$tmp"

  if grep -q "^$key=" "$tmp"; then
    sed "s/^$key=.*/$key=$val/" "$tmp" > "$tmp.new" && mv "$tmp.new" "$tmp"
  else
    printf '%s=%s\n' "$key" "$val" >> "$tmp"
  fi

  mv "$tmp" "$STATE_FILE"
}

get_scheme_state() {
  key="$1"

  [ -r "$STATE_FILE" ] && grep "^$key=" "$STATE_FILE" | sed 's/^[^=]*=//'
}

get_filepath_stem() {
  filepath="$1"

  filename=${filepath##*/} # strip directories
  stem=${filename%.*}      # strip extension

  printf '%s\n' "$stem"
}

get_stem_filepath() {
  stem="$1"

  filepath="$SCHEMES_DIR/$1.y*ml"
  set -- $filepath

  [ -r "$1" ] && printf '%s\n' "$1" || return 1
}

get_random_scheme_filepath() {
  set -- "$SCHEMES_DIR/"*.y*ml

  [ -r "$1" ] || {
    echo "error: no scheme files found in $SCHEMES_DIR" >&2
    return 1
  }

  count=$#

  # Read two bytes from `/dev/urandom` and print as a 16-bit integer (0–65535)
  # `od`: octal dump (from `coreutils`)
  # `-An`: no address — suppress offset column
  # `-N2`: read 2 bytes
  # `-tu2`: output as unsigned 2-byte integer
  # `tr`: translate/delete characters
  # `-d`: delete
  random_num=$(od -An -N2 -tu2 /dev/urandom 2>/dev/null | tr -d ' ')

  # If `$random_num` is empty, generate pseudo-random number by concatenating process
  # ID (`$$`) and current timestamp (or 1 if `date` fails).
  [ -n "$random_num" ] || random_num=$$$(date +%s 2>/dev/null || echo 1)

  target_index=$(( random_num % count ))

  index=0
  for filepath in "$@"; do
    [ $index -eq $target_index ] && {
      printf '%s\n' "$filepath"
      return
    }
    index=$(( index + 1 ))
  done
}

parse_scheme_file() {
  filepath="$1"

  for i in $(seq 0 15); do
    key=$(printf 'base%02X' "$i")

    line=$(grep -m1 -E "^  $key: \"#[0-9A-Fa-f]{6}\"" "$filepath") || line=

    [ -n "$line" ] || {
      echo "error: scheme file missing $key" >&2
      return 1
    }

    hex=${line#*\"#} # drop everything up to and including the opening "#"
    hex=${hex%\"*}   # drop the trailing quote and anything after

    printf '%s\n' "$hex"
  done
}

emit_osc()  {
  code="$1"; hex="$2"

  printf '\033]%s;#%s\033\\' "$code" "$hex"
}

emit_osc_4() {
  index="$1"; hex="$2"

  printf '\033]4;%s;#%s\033\\' "$index" "$hex"
}

apply_scheme() {
  set --
  while IFS= read -r line; do
    set -- "$@" "$line"
  done

  [ $# -ge 16 ] || {
    echo "error: fewer than 16 colors provided" >&2
    return 1
  }

  emit_osc 10 "$6"    # foreground
  emit_osc 11 "$1"    # background
  emit_osc 12 "${14}" # cursor

  # palette
  emit_osc_4 0  "$1"
  emit_osc_4 1  "$9"
  emit_osc_4 2  "${12}"
  emit_osc_4 3  "${11}"
  emit_osc_4 4  "${14}"
  emit_osc_4 5  "${15}"
  emit_osc_4 6  "${13}"
  emit_osc_4 7  "$6"

  emit_osc_4 8  "$4"
  emit_osc_4 9  "$9"
  emit_osc_4 10 "${12}"
  emit_osc_4 11 "${11}"
  emit_osc_4 12 "${14}"
  emit_osc_4 13 "${15}"
  emit_osc_4 14 "${13}"
  emit_osc_4 15 "$8"

  emit_osc_4 16 "${10}"
  emit_osc_4 17 "${16}"
  emit_osc_4 18 "$2"
  emit_osc_4 19 "$3"
  emit_osc_4 20 "$5"
  emit_osc_4 21 "$7"
}

show_help() {
  cat <<EOF
usage: scheme [-l|--last] [-r|--random] [-d|--default] [-s|--save] [<scheme-name>]

Flags:
  -d, --default   apply default scheme
  -l, --last      apply last scheme
  -r, --random    apply random scheme
  -s, --save      save provided or last scheme as default
EOF
  exit 0
}

determine_scheme_filepath() {
  arg_scheme_name=$1; random=$2; last=$3; default=$4; save=$5

  # 1. named
  if [ -n "$arg_scheme_name" ]; then
    echo "named scheme selected: $arg_scheme_name" >&2
    get_stem_filepath "$arg_scheme_name" && return 0
    echo "error: scheme not found: $arg_scheme_name" >&2
    return 1
  fi

  # 2. random
  if [ "$random" = "1" ]; then
    filepath="$(get_random_scheme_filepath)"
    if [ -n "$filepath" ]; then
      random_scheme_name="$(get_filepath_stem "$filepath")"
      echo "random scheme selected: $random_scheme_name" >&2
      printf '%s\n' "$filepath"
      return 0
    fi
    echo "error: no scheme files found in $SCHEMES_DIR" >&2
    return 1
  fi

  # 3. last explicitly
  if [ "$last" = "1" ]; then
    selected="$(get_scheme_state last)"
    echo "last scheme selected explicitly: $selected" >&2

  # 4. default explicitly
  elif [ "$default" = "1" ]; then
    selected="$(get_scheme_state default)"
    echo "default scheme selected explicitly: $selected" >&2

  # 5. save → interpret as "use last" when no selector
  elif [ "$save" = "1" ]; then
    selected="$(get_scheme_state last)"
    echo "last scheme selected implicitly: $selected" >&2

  # 6. fallback default
  else
    selected="$(get_scheme_state default)"
    echo "default scheme selected implicitly: $selected" >&2
  fi

  [ -n "$selected" ] || {
    echo "error: no matching scheme in $STATE_FILE" >&2
    return 1
  }

  get_stem_filepath "$selected" && return 0
  echo "error: scheme not found: $selected" >&2
  return 1
}

# Parse args
help=0
last=0
random=0
default=0
save=0
arg_scheme_name=""

while [ $# -gt 0 ]; do
  case "${1:-}" in
    -h|--help) help=1 ;;
    -l|--last) last=1 ;;
    -r|--random) random=1 ;;
    -d|--default) default=1 ;;
    -s|--save) save=1 ;;
    --) shift; break ;;
    -*) echo "unknown flag: $1" >&2; show_help ;;
    *) arg_scheme_name="$1" ;;
  esac
  shift || true
done

# Core logic
if [ "$help" -eq 1 ]; then
  show_help
  exit 0
fi

filepath=$(determine_scheme_filepath \
  "$arg_scheme_name" "$random" "$last" "$default" "$save" ) || {
  echo "error: failed to get scheme filepath" >&2
  exit 1
}
# echo "selected scheme filepath: $filepath" >&2

parsed=$(parse_scheme_file "$filepath") || {
  echo "error: failed to parse scheme" >&2
  exit 1
}
# printf '%s\n' "$parsed" >&2

printf '%s\n' "$parsed" | apply_scheme || {
  echo "error: failed to apply scheme" >&2
  exit 1
}

applied_scheme_name=$(get_filepath_stem "$filepath")
# echo "applied scheme: $applied_scheme_name" >&2

if [ -n "$arg_scheme_name" ] || \
   [ "$last" -eq 1 ] || \
   [ "$random" -eq 1 ] || \
   [ "$default" -eq 1 ] || \
   [ "$save" -eq 1 ]; then
  set_scheme_state last "$applied_scheme_name"
fi

if [ "$save" -eq 1 ]; then
  set_scheme_state default "$applied_scheme_name"
fi

exit 0
